name: wanstage release

on:
  push:
    tags:
      - 'v*'
  workflow_dispatch:
    inputs:
      tag:
        description: "Tag to release (e.g. v20250926-rX)"
        required: false

permissions:
  contents: write

concurrency:
  group: release-${{ github.ref_type == 'tag' && github.ref_name || inputs.tag || 'manual' }}
  cancel-in-progress: false

jobs:
  release:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      # ---- タグ決定（push/dispatch 両対応・フォールバック付き） ----
      - name: Resolve TAG
        shell: bash
        run: |
          set -euo pipefail
          if [[ "${GITHUB_EVENT_NAME}" == "workflow_dispatch" ]]; then
            TAG="${{ inputs.tag || '' }}"
          else
            TAG="${GITHUB_REF_NAME:-}"
          fi
          if [[ -z "${TAG:-}" ]]; then
            if [[ "${GITHUB_REF_TYPE:-}" == "tag" && -n "${GITHUB_REF_NAME:-}" ]]; then
              TAG="${GITHUB_REF_NAME}"
            fi
          fi
          [[ -n "${TAG:-}" ]] || { echo "[error] TAG not resolved"; exit 1; }
          echo "TAG=${TAG}" | tee -a "$GITHUB_ENV"
          echo "TAG_NO_V=${TAG#v}" | tee -a "$GITHUB_ENV"
          echo "[info] TAG=$TAG  TAG_NO_V=${TAG#v}"

      # ---- 最小成果物（常に作るフェイルセーフ） ----
      - name: Build minimal artifacts (fallback)
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p out
          printf "WANSTAGE release bundle for %s\n" "${TAG}" > "out/README_${TAG}.txt"
          tar -czf "release_all_${TAG}.tar.gz" -C out .
          (cd out && zip -r "../release_all_${TAG}.zip" . > /dev/null)
          shasum -a 256 "release_all_${TAG}.tar.gz" "release_all_${TAG}.zip" > "SHA256SUMS_${TAG}.txt"

      # ---- pack-by-category（存在すれば反映） ----
      - name: Optional pack-by-category (merge)
        shell: bash
        run: |
          set -euo pipefail
          OUTDIR="release_all_${TAG_NO_V}"
          mkdir -p "$OUTDIR"
          if [[ -x ./pack-by-category.zsh && -f ./categories_latest.csv ]]; then
            echo "[info] run pack-by-category.zsh -> $OUTDIR"
            ./pack-by-category.zsh -c ./categories_latest.csv -o "${TAG_NO_V}" || echo "[warn] pack failed (ignored)"
          else
            echo "[info] pack-by-category not present -> minimal tree"
          fi
          printf "WANSTAGE release bundle for %s\n" "${TAG}" > "$OUTDIR/README_${TAG}.txt"
          if [[ -n "${{ secrets.MINISIGN_PUBKEY }}" ]]; then
            printf 'untrusted comment: minisign public key\n%s\n' "${{ secrets.MINISIGN_PUBKEY }}" > "$OUTDIR/minisign_pubkey.txt"
          elif [[ -f minisign_pubkey.txt ]]; then
            cp -a minisign_pubkey.txt "$OUTDIR/"
          fi
          tar -czf "release_packed_${TAG}.tar.gz" -C "$OUTDIR" .
          (cd "$OUTDIR" && zip -r "../release_packed_${TAG}.zip" . > /dev/null)
          shasum -a 256 "release_packed_${TAG}.tar.gz" "release_packed_${TAG}.zip" >> "SHA256SUMS_${TAG}.txt"

      # ---- minisign（鍵があれば署名） ----
      - name: Install minisign
        if: ${{ secrets.MINISIGN_SECKEY_B64 != '' }}
        run: |
          set -euo pipefail
          sudo apt-get update -y
          sudo apt-get install -y minisign expect

      - name: Prepare minisign keys
        if: ${{ secrets.MINISIGN_SECKEY_B64 != '' }}
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p "$HOME/.minisign_keys"
          echo "${{ secrets.MINISIGN_SECKEY_B64 }}" | base64 -d > "$HOME/.minisign_keys/minisign_seckey.txt"
          chmod 600 "$HOME/.minisign_keys/minisign_seckey.txt"
          if [[ -n "${{ secrets.MINISIGN_PUBKEY }}" ]]; then
            printf 'untrusted comment: minisign public key\n%s\n' "${{ secrets.MINISIGN_PUBKEY }}" > minisign_pubkey.txt
          else
            minisign -R -s "$HOME/.minisign_keys/minisign_seckey.txt" -p minisign_pubkey.txt -f || true
          fi

      - name: Sign artifacts (.tar.gz/.zip/SUMS)
        if: ${{ secrets.MINISIGN_SECKEY_B64 != '' }}
        shell: bash
        env:
          MINISIGN_PASSPHRASE: ${{ secrets.MINISIGN_PASSPHRASE }}
        run: |
          set -euo pipefail
          sign_one() {
            local f="$1"; local sig="${f}.minisig"
            if [[ -n "${MINISIGN_PASSPHRASE:-}" ]]; then
              expect <<'EXP'
set timeout -1
spawn minisign -S -s "$env(HOME)/.minisign_keys/minisign_seckey.txt" -m "'"$f"'" -x "'"$sig"'"
expect "Enter passphrase: "
send -- "${env(MINISIGN_PASSPHRASE)}\r"
expect eof
EXP
            else
              minisign -S -s "$HOME/.minisign_keys/minisign_seckey.txt" -m "$f" -x "$sig"
            fi
          }
          artifacts=( "release_all_${TAG}.tar.gz" "release_all_${TAG}.zip" \
                      "release_packed_${TAG}.tar.gz" "release_packed_${TAG}.zip" \
                      "SHA256SUMS_${TAG}.txt" )
          for a in "${artifacts[@]}"; do
            [[ -f "$a" ]] && { echo "[sign] $a"; sign_one "$a"; } || echo "[info] skip $a (not found)"
          done

      # ---- GitHub Release（作成/更新 & すべて添付） ----
      - name: Create/Update GitHub Release (attach everything)
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ env.TAG }}
          name: ${{ env.TAG }}
          generate_release_notes: true
          files: |
            release_all_${{ env.TAG }}.tar.gz
            release_all_${{ env.TAG }}.zip
            release_packed_${{ env.TAG }}.tar.gz
            release_packed_${{ env.TAG }}.zip
            SHA256SUMS_${{ env.TAG }}.txt
            release_all_${{ env.TAG }}.tar.gz.minisig
            release_all_${{ env.TAG }}.zip.minisig
            release_packed_${{ env.TAG }}.tar.gz.minisig
            release_packed_${{ env.TAG }}.zip.minisig
            SHA256SUMS_${{ env.TAG }}.txt.minisig
            minisign_pubkey.txt

      # ---- 検証スニペットをノートへ追記 ----
      - name: Append verification snippet to release notes
        shell: bash
        run: |
          set -euo pipefail
          cat > verify.txt <<TXT
## Verify

\`\`\`bash
# Download
gh release download -R ${GITHUB_REPOSITORY} ${TAG} \
  -p "SHA256SUMS_${TAG}.txt" \
  -p "minisign_pubkey.txt" \
  -p "release_*_${TAG}.tar.gz" \
  -p "release_*_${TAG}.zip"

# Signature (SUMS)
minisign -Vm "SHA256SUMS_${TAG}.txt" -p minisign_pubkey.txt

# Hash
shasum -a 256 -c "SHA256SUMS_${TAG}.txt"
\`\`\`
TXT
          gh release edit -R "${GITHUB_REPOSITORY}" "${TAG}" --notes-file verify.txt
