import glob
import traceback
import base64
from pathlib import Path
from datetime import datetime, timezone
import sqlite3
import time
import json
#!/usr/bin/env python3
import os, sys, json, datetime, sqlite3
from dotenv import load_dotenv

# .env を読み込む（HOME 基点）
load_dotenv(os.path.expanduser('~/WANSTAGE/.env'))

# 依存
import requests
from google import genai
from google.genai import types

# ---- macOS プレビュー ----
import subprocess, shutil
def preview_image(path: str | None):
    if not path or not os.path.exists(path):
        print(f"[preview] file not found or empty: {path}")
        return
    mode = os.getenv("WAN_PREVIEW_MODE", "open").lower()
    if mode == "none":
        print(f"[preview] skipped -> {path}")
        return
    try:
        if mode == "quicklook" and shutil.which("qlmanage"):
            subprocess.Popen(["qlmanage","-p",path],
                             stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
            print(f"[preview] quicklook -> {path}")
        else:
            subprocess.run(["open", path], check=False)
            print(f"[preview] open -> {path}")
    except Exception as e:
        print(f"[preview] error: {e}")

# ---- 汎用 ----
def _ensure_outdir() -> str:
    out_dir = os.getenv('OUT_DIR', os.path.expanduser('~/WANSTAGE/out/insta'))
    os.makedirs(out_dir, exist_ok=True)
    return out_dir

def _latest_image_from_outdir() -> str | None:
    import glob
    out = _ensure_outdir()
    cand = []
    for ext in ("*.jpg","*.jpeg","*.png","*.webp"):
        cand += glob.glob(os.path.join(out, ext))
    if not cand:
        return None
    cand.sort(key=lambda p: os.path.getmtime(p), reverse=True)
    return cand[0]

# ---- Gemini caption ----
def generate_caption(prompt: str) -> str:
    model = os.getenv('GEMINI_MODEL', 'gemini-2.5-flash')
    temp = float(os.getenv('CAPTION_TEMPERATURE', '0.7'))
    client = genai.Client(
        vertexai=True,
        project=os.getenv('GOOGLE_CLOUD_PROJECT'),
        location=os.getenv('GOOGLE_CLOUD_LOCATION', 'global'),
    )
    cfg = types.GenerateContentConfig(temperature=temp)
    resp = client.models.generate_content(model=model, contents=prompt, config=cfg)
    text = (resp.text or '').strip()
    template = os.getenv('CAPTION_TEMPLATE', '{poem}\\n\\n{hashtags}')
    hashtags = os.getenv('DEFAULT_HASHTAGS', '#ポエム #癒し #写真')
    return template.format(poem=text, hashtags=hashtags)

# ---- Instagram Graph API ----
def post_to_instagram(media_path_or_url: str, caption: str, publish: bool = True, dry_run: bool = False):
    base = os.getenv('IG_GRAPH_API_BASE', 'https://graph.facebook.com/v21.0').rstrip('/')
    igid = os.getenv('IG_BUSINESS_ID')
    token = os.getenv('FB_PAGE_TOKEN')

    # image_url を決定
    m = media_path_or_url
    if not (m.startswith('http://') or m.startswith('https://')):
        override = os.getenv('WAN_IMAGE_URL')
        if override:
            m = override
        else:
            raise RuntimeError('Instagram Graph API は image_url が必須です。公開URLを指定してください（WAN_IMAGE_URL でも可）。')

    if dry_run:
        print('[IG][dry-run] create container -> publish をスキップ')
        return {'ok': True, 'dry_run': True, 'image_url': m, 'caption': caption}

    if not igid or not token:
        raise RuntimeError('IG_BUSINESS_ID / FB_PAGE_TOKEN が未設定です')

    # 1) コンテナ作成
    r1 = requests.post(f'{base}/{igid}/media',
                       data={'image_url': m, 'caption': caption, 'access_token': token},
                       timeout=60)
    try:
        j1 = r1.json()
    except Exception:
        j1 = {}
    if r1.status_code >= 400 or 'id' not in j1:
        raise RuntimeError(f'Create container failed: {r1.status_code} {j1}')
    creation_id = j1['id']

    # 2) 公開
    if publish:
        r2 = requests.post(f'{base}/{igid}/media_publish',
                           data={'creation_id': creation_id, 'access_token': token},
                           timeout=60)
        try:
            j2 = r2.json()
        except Exception:
            j2 = {}
        if r2.status_code >= 400:
            raise RuntimeError(f'Publish failed: {r2.status_code} {j2}')
        return {'ok': True, 'id': j2.get('id'), 'creation_id': creation_id}

    return {'ok': True, 'creation_id': creation_id, 'published': False}

# ---- SQLite ログ ----
def init_log_db(db_path: str | None = None):
    if not db_path:
        db_path = os.getenv('LOG_DB_PATH', os.path.expanduser('~/WANSTAGE/post_log.sqlite3'))
    os.makedirs(os.path.dirname(db_path), exist_ok=True)
    conn = sqlite3.connect(db_path)
    cur = conn.cursor()
    cur.execute("""
CREATE TABLE IF NOT EXISTS post_log (
  id INTEGER PRIMARY KEY,
  timestamp TEXT,
  image_path TEXT,
  image_url TEXT,
  caption TEXT,
  response_json TEXT,
  success INTEGER
)
""")
    conn.commit()
    return conn

def log_post(image_path, image_url, caption, response_dict, success: int):
    try:
        conn = init_log_db()
        cur = conn.cursor()
        cur.execute(
            "INSERT INTO post_log(timestamp, image_path, image_url, caption, response_json, success) VALUES (?, ?, ?, ?, ?, ?)",
            (datetime.datetime.now(timezone.utc).isoformat(),
             str(image_path) if image_path else None,
             str(image_url) if image_url else None,
             caption,
             json.dumps(response_dict, ensure_ascii=False),
             int(success))
        )
        conn.commit(); conn.close()
    except Exception as e:
        print("[log] failed:", e)

# ---- GCS アップロード → URL 取得 ----
def gcs_upload_and_make_public(local_path: str) -> str:
    from google.cloud import storage
    try:
        import magic
        mime = magic.from_file(local_path, mime=True) or "application/octet-stream"
    except Exception:
        # 拡張子で簡易判定
        ext = os.path.splitext(local_path)[1].lower()
        mime = "image/jpeg" if ext in (".jpg",".jpeg") else "image/png" if ext==".png" else "application/octet-stream"

    bucket_name = os.getenv("GCS_BUCKET")
    if not bucket_name:
        raise RuntimeError("GCS_BUCKET が未設定です")

    client = storage.Client()  # ADC
    bucket = client.bucket(bucket_name)
    ts = datetime.datetime.now().strftime("%Y/%m/%d/%H%M%S")
    base = os.path.basename(local_path)
    blob = bucket.blob(f"insta/{ts}_{base}")
    blob.upload_from_filename(local_path, content_type=mime)

    if os.getenv("WAN_GCS_SIGNED_URL","0") == "1":
        url = blob.generate_signed_url(version="v4", expiration=datetime.timedelta(hours=1), method="GET")
        return url
    else:
        try:
            blob.make_public()
        except Exception as _:
            # uniform access OFF等で失敗する場合は Storage IAM で allUsers:objectViewer を付与
            pass
        return f"https://storage.googleapis.com/{bucket_name}/{blob.name}"

# ---- パイプライン ----
def run_once_pipeline(publish: bool, dry_run: bool):
    # 画像決定
    img = os.getenv("WAN_LAST_IMAGE")
    if not img:
        img = _latest_image_from_outdir()
    if not img or not os.path.exists(img):
        raise FileNotFoundError(f"画像が見つかりません: {img}")

    # 画像存在確認（無ければ自動生成）  # _pipeline_autogen_guard
    if not (locals().get('img') or globals().get('img')):
        img = _latest_image_from_outdir()
    if not img:
        # create new dummy in OUT_DIR
        out_dir = os.environ.get('OUT_DIR') or os.path.expanduser('~/Library/Mobile Documents/com~apple~CloudDocs/WANSTAGE/out/insta')
        os.makedirs(out_dir, exist_ok=True)
        from datetime import datetime as _dt
        img = os.path.join(out_dir, f"autogen_{_dt.now().strftime('%Y%m%d_%H%M%S')}.png")
        _touch_dummy(img)

    # プレビュー
    preview_image(img)

    # 画像URL決定（既存URL or GCSへアップロード）
    image_url = os.getenv("WAN_IMAGE_URL")
    if not (image_url and (image_url.startswith("http://") or image_url.startswith("https://"))):
        image_url = gcs_upload_and_make_public_safe(img)
    os.environ["WAN_IMAGE_URL"] = image_url  # 後段へ伝播


    # キャプション生成
    prompt = os.getenv("WAN_CAPTION_PROMPT", "やさしい一言の日本語キャプションを。絵文字は控えめ。")
    caption = generate_caption(prompt)

    # IG 投稿
    try:
        result = post_to_instagram(image_url, caption, publish=publish, dry_run=dry_run)
        ok = bool(result.get("ok"))
    except Exception as e:
        result = {"ok": False, "error": str(e), "image_url": image_url}
        ok = False

    # ログ
    log_post(img, image_url, caption, result, 1 if ok else 0)

    # 出力
    print(json.dumps({
        "ok": ok,
        "image_path": img,
        "image_url": image_url,
        "caption": caption,
        "result": result
    }, ensure_ascii=False, indent=2))
# --- PATCH:gcs_guard START ---
def _gcs_bucket_and_key_from_env(img_path):
    import os, os.path
    from datetime import datetime
    bucket = os.environ.get("WAN_GCS_BUCKET","").strip()
    key = "wanstage/{}/{}".format(datetime.now().strftime("%Y/%m/%d"), os.path.basename(img_path))
    return bucket, key

def gcs_upload_and_make_public_safe(img_path):
    use_gcs = str(os.environ.get("WAN_USE_GCS","false")).lower() == "true"
    bucket, key = _gcs_bucket_and_key_from_env(img_path)
    if not (use_gcs and bucket):
        return "file://{}".format(img_path)
    try:
        if "gcs_upload_and_make_public" in globals():
            try:
                return globals()["gcs_upload_and_make_public"](img_path)
            except TypeError:
                return globals()["gcs_upload_and_make_public"](img_path, bucket, key)
        from google.cloud import storage
        client = storage.Client()
        b = client.bucket(bucket)
        blob = b.blob(key)
        blob.upload_from_filename(img_path)
        try:
            blob.make_public()
        except Exception:
            pass
        return "https://storage.googleapis.com/{}/{}".format(bucket, key)
    except Exception:
        return "file://{}".format(img_path)
# --- PATCH:gcs_guard END ---

def generate_caption(prompt):
    """
    Gemini caption generator:
      1) Prefer API key (no ADC needed).
      2) Fallback to Vertex/ADC only if explicitly enabled or API key missing.
      3) Final fallback returns a safe default caption.
    """
    try:
        from google import genai
        import os

        use_vertex = str(os.environ.get("GOOGLE_GENAI_USE_VERTEXAI","false")).lower() == "true"
        api_key = (os.environ.get("GOOGLE_API_KEY") or "").strip()
        model = os.environ.get("WAN_GEMINI_MODEL","gemini-2.5-flash")
        try:
            temperature = float(os.environ.get("WAN_GEMINI_TEMPERATURE", "0.7"))
        except Exception:
            temperature = 0.7

        # 1) API key first (free tier, no ADC)
        if api_key and not use_vertex:
            client = genai.Client(api_key=api_key)
            resp = client.models.generate_content(
                model=model,
                contents=prompt,
                config={"temperature": temperature}
            )
            text = getattr(resp, "text", None)
            return (text or "Test post #wanstage").strip()

        # 2) Vertex (ADC) path if explicitly enabled or API key is empty
        client = genai.Client(
            vertexai=True,
            project=os.getenv("GOOGLE_CLOUD_PROJECT"),
            location=os.getenv("GOOGLE_CLOUD_LOCATION", "global"),
        )
        resp = client.models.generate_content(
            model=model,
            contents=prompt,
            config={"temperature": temperature}
        )
        text = getattr(resp, "text", None)
        return (text or "Test post #wanstage").strip()

    except Exception as e:
        print("[caption] fallback due to:", e)
        return "Test post #wanstage"


if __name__ == "__main__":
    import argparse
    ap = argparse.ArgumentParser()
    ap.add_argument("--publish", action="store_true", help="実投稿（media→publish）")
    ap.add_argument("--no-dry-run", action="store_true", help="IG APIを実際に呼ぶ（危険）")
    args = ap.parse_args()
    publish = bool(args.publish or os.getenv("WAN_IG_PUBLISH","0")=="1")
    dry_run = not args.no_dry_run and (os.getenv("WAN_DRY_RUN","1")=="1")
    run_once_pipeline(publish=publish, dry_run=dry_run)



# --- WAN unified pipeline ---
def _latest_file(out_dir: str) -> str | None:
    pats = ["*.jpg","*.jpeg","*.png","*.webp"]
    files = []
    for p in pats:
        files.extend(glob.glob(os.path.join(out_dir, p)))
    if not files:
        return None
    files.sort(key=lambda p: os.path.getmtime(p), reverse=True)
    return files[0]

def run_once_pipeline():
    # 1) 対象画像の決定（WAN_LAST_IMAGE > OUT_DIR 最新）
    out_dir = os.getenv('OUT_DIR', os.path.expanduser('~/WANSTAGE/out/insta'))
    img = os.getenv('WAN_LAST_IMAGE') or _latest_file(out_dir)
    if not img or not os.path.exists(img):
        raise RuntimeError(f"画像が見つかりません: {img}")

    # 2) プレビュー（方針により open/quicklook/none）
    try:
        preview_image(img)
    except Exception as e:
        print("[preview] ignore error:", e)

    # 3) GCSへアップロード → 公開URL
    bucket = os.getenv('WAN_GCS_BUCKET')
    if not bucket:
        raise RuntimeError("環境変数 WAN_GCS_BUCKET が未設定です")
    def _do_upload():
        return gcs_upload_and_make_public(img, bucket)
    url = retry(_do_upload, tries=3, wait_sec=4, label="gcs upload")
    os.environ['WAN_IMAGE_URL'] = url  # 既存 post_to_instagram が拾える

    # 4) キャプション生成（Gemini）
    default_prompt = os.getenv('DEFAULT_CAPTION_PROMPT', '写真の雰囲気に合う短い日本語キャプションと軽いハッシュタグ')
    caption = generate_caption(default_prompt)

    # 5) Instagram 投稿（本番）。失敗はリトライ
    def _do_post():
        return post_to_instagram(url, caption, publish=True, dry_run=False)
    result = retry(_do_post, tries=3, wait_sec=6, label="instagram post")

    # 6) ログ（SQLite）
    try:
        ensure_db_and_log(img, url, caption, result, bool(result.get('ok')))
    except Exception as e:
        print("[log] failed:", e)

    print("\n[OK] Posted:", json.dumps({'image': img, 'url': url, 'result': result}, ensure_ascii=False))
    return result

if __name__ == '__main__':
    run_once = os.getenv('WAN_RUN_ONCE','1') == '1'
    if run_once:
        run_once_pipeline()

# --- PATCH:retry START ---
def retry(max_attempts=3, backoff_sec=1.5, exceptions=(Exception,)):
    def deco(fn):
        def wrapper(*args, **kwargs):
            last = None
            for i in range(1, max_attempts+1):
                try:
                    return fn(*args, **kwargs)
                except exceptions as e:
                    last = e
                    if i == max_attempts:
                        raise
                    time.sleep(backoff_sec * i)
            raise last
        return wrapper
    return deco
# --- PATCH:retry END ---

# --- PATCH:gcs_upload_and_make_public START ---
@retry(max_attempts=3)
def gcs_upload_and_make_public(local_path:str, bucket_name:str, dest_key:str)->str:
    """
    Returns public URL (https://storage.googleapis.com/{bucket}/{key})
    前提: google-cloud-storage がインストール済み、認証は ADC (gcloud auth application-default login)
    """
    try:
        from google.cloud import storage  # 遅延import
    except Exception as e:
        raise RuntimeError("google-cloud-storage が未インストールです") from e
    client = storage.Client()
    bucket = client.bucket(bucket_name)
    blob = bucket.blob(dest_key)
    blob.upload_from_filename(local_path)
    try:
        blob.make_public()  # ACL公開
    except Exception:
        pass  # IAM公開の環境でもURLは有効
    return f"https://storage.googleapis.com/{bucket_name}/{dest_key}"
# --- PATCH:gcs_upload_and_make_public END ---

# --- PATCH:ensure_db_and_log START ---
def ensure_db_and_log(db_path:str, record:dict):
    """
    post_log( id, timestamp, image_path, image_url, caption, response_json, success )
    が無ければ作成し、レコードを追記する。
    """
    import sqlite3, json, os
    os.makedirs(os.path.dirname(db_path), exist_ok=True) if os.path.dirname(db_path) else None
    conn = sqlite3.connect(db_path)
    try:
        cur = conn.cursor()
        cur.execute("""
        CREATE TABLE IF NOT EXISTS post_log(
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            timestamp TEXT,
            image_path TEXT,
            image_url TEXT,
            caption TEXT,
            response_json TEXT,
            success INTEGER
        )
        """)
        cur.execute("""
            INSERT INTO post_log(timestamp, image_path, image_url, caption, response_json, success)
            VALUES(?,?,?,?,?,?)
        """, (
            record.get("timestamp"),
            record.get("image_path"),
            record.get("image_url"),
            record.get("caption"),
            json.dumps(record.get("response_json", {}), ensure_ascii=False),
            1 if record.get("success") else 0
        ))
        conn.commit()
    finally:
        conn.close()
# --- PATCH:ensure_db_and_log END ---

# --- PATCH:run_once_pipeline START ---
def _load_env_if_available(dotenv_path:str):
    try:
        from dotenv import load_dotenv
        load_dotenv(dotenv_path)
    except Exception:
        pass

def _ensure_iclouddir()->str:
    default_out = os.path.expanduser('~/Library/Mobile Documents/com~apple~CloudDocs/WANSTAGE/out/insta')
    os.makedirs(default_out, exist_ok=True)
    return os.environ.get("OUT_DIR", default_out)

def _safe_preview(path:str):
    try:
        # 既存 preview_image を優先利用
        if 'preview_image' in globals():
            return globals()['preview_image'](path)
        # フォールバック: open
        mode = os.environ.get("WAN_PREVIEW_MODE","open")
        if mode == "open" and sys.platform == "darwin":
            os.system(f'open "{path}"')
    except Exception:
        pass

def _tiny_png(path:str):
    # PIL不要の最小PNGを書き出し（1x1透明）
    import base64
    data = base64.b64decode(b'iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR4nGNgYAAAAAMAASsJTYQAAAAASUVORK5CYII=')
    with open(path, "wb") as f:
        f.write(data)

def _maybe_generate_image(out_dir:str)->str:
    # 既存の生成機能があれば利用、それ以外はダミー生成
    fname = f"autogen_{datetime.now().strftime('%Y%m%d_%H%M%S')}.png"
    out = os.path.join(out_dir, fname)
    try:
        if 'generate_image' in globals():
            return globals()['generate_image'](out_dir)
    except Exception:
        pass
    _tiny_png(out)
    return out

def _maybe_caption(image_path:str)->str:
    try:
        if 'generate_caption' in globals():
            return globals()['generate_caption'](image_path)
    except Exception:
        pass
    return "WANSTAGE auto-post"

def _maybe_instagram_post(image_url:str, caption:str):
    try:
        if 'post_to_instagram' in globals():
            return globals()['post_to_instagram'](image_url, caption)
    except Exception as e:
        return {"error": str(e)}
    return {"dry_run": True, "message": "post_to_instagram not found"}

def run_once_pipeline():
    # .env読込
    _load_env_if_available(os.path.expanduser('~/WANSTAGE/.env'))

    out_dir = _ensure_iclouddir()
    db_path = os.environ.get("LOG_DB_PATH", os.path.expanduser('~/WANSTAGE/post_log.sqlite3'))
    use_gcs = str(os.environ.get("WAN_USE_GCS","false")).lower() == "true"
    bucket = os.environ.get("WAN_GCS_BUCKET","")
    dry_run_default = str(os.environ.get("WAN_DRY_RUN","1")) in ("1","true","True")
    ig_publish = str(os.environ.get("WAN_IG_PUBLISH","0")) in ("1","true","True")

    # 1) 画像生成→保存
    image_path = _maybe_generate_image(out_dir)

    # 2) プレビュー
    _safe_preview(image_path)

    # 3) GCSアップロード→URL
    image_url = None
    if use_gcs and bucket:
        key = f"wanstage/{datetime.now().strftime('%Y/%m/%d')}/{os.path.basename(image_path)}"
        try:
            image_url = gcs_upload_and_make_public(image_path, bucket, key)
        except Exception as e:
            image_url = f"file://{image_path}"
    else:
        image_url = f"file://{image_path}"

    # WAN_IMAGE_URLに配線（下流互換）
    os.environ["WAN_IMAGE_URL"] = image_url

    # 4) Geminiキャプション
    caption = _maybe_caption(image_path)

    # 5) IG投稿（dry-run既定、本番は環境変数で明示）
    if dry_run_default and not ig_publish:
        resp = {"dry_run": True, "image_url": image_url, "caption": caption}
        success = True
    else:
        resp = _maybe_instagram_post(image_url, caption)
        success = not isinstance(resp, dict) or not resp.get("error")

    # 6) SQLiteログ
    ensure_db_and_log(db_path, {
        "timestamp": datetime.now().isoformat(timespec="seconds"),
        "image_path": image_path,
        "image_url": image_url,
        "caption": caption,
        "response_json": resp,
        "success": bool(success),
    })
    return {"image_path": image_path, "image_url": image_url, "caption": caption, "success": bool(success), "response": resp}

if __name__ == "__main__":
    try:
        out = run_once_pipeline()
        # 非対話: 出力は標準にJSONだけ
        print(json.dumps(out, ensure_ascii=False))
    except Exception as e:
        import traceback
        err = {"success": False, "error": str(e), "trace": traceback.format_exc()}
        print(json.dumps(err, ensure_ascii=False))
        raise
# --- PATCH:run_once_pipeline END ---


def _touch_dummy(pth: str):
    """Create a 1x1 PNG dummy image (base64)."""
    data = base64.b64decode(
        b'iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR4nGNgYAAAAAMAASsJTYQAAAAASUVORK5CYII='
    )
    os.makedirs(os.path.dirname(pth), exist_ok=True)
    with open(pth, 'wb') as f:
        f.write(data)
